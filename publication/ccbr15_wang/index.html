<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.27.1" />
  <meta name="author" content="Yida Wang">
  <meta name="description" content="Ph.D Student in Machine Learning and Computer Vision">

  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="/css/highlight.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="/css/hugo-academic.css">
  

  

  <link rel="alternate" href="https://wangyida.github.io/index.xml" type="application/rss+xml" title="Yida Wang&#39;s personal website">
  <link rel="feed" href="https://wangyida.github.io/index.xml" type="application/rss+xml" title="Yida Wang&#39;s personal website">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="https://wangyida.github.io/publication/ccbr15_wang/">

  

  <title>Face Recognition Using Local PCA Filters | Yida Wang&#39;s personal website</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Yida Wang&#39;s personal website</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#publications">
            
            <span>Publications</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#projects">
            
            <span>Projects</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#teaching">
            
            <span>Teaching</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contact</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>

<div class="pub" itemscope itemtype="http://schema.org/CreativeWork">

  


  <div class="container pub-title">
    <h1 itemprop="name">Face Recognition Using Local PCA Filters</h1>
    <span class="pub-authors" itemprop="author">
      
      Yida Wang, Shasha Li, Jiani Hu, Weihong Deng
      
    </span>
    <span class="pull-right">
      
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fwangyida.github.io%2fpublication%2fccbr15_wang%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Face%20Recognition%20Using%20Local%20PCA%20Filters&amp;url=https%3a%2f%2fwangyida.github.io%2fpublication%2fccbr15_wang%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwangyida.github.io%2fpublication%2fccbr15_wang%2f&amp;title=Face%20Recognition%20Using%20Local%20PCA%20Filters"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fwangyida.github.io%2fpublication%2fccbr15_wang%2f&amp;title=Face%20Recognition%20Using%20Local%20PCA%20Filters"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Face%20Recognition%20Using%20Local%20PCA%20Filters&amp;body=https%3a%2f%2fwangyida.github.io%2fpublication%2fccbr15_wang%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


    </span>
  </div>

</div>
<div class="article-container">

  

  <h3>Abstract</h3>
  <p class="pub-abstract" itemprop="text">We propose an efficient feature extraction architecture based on PCANet. Our method performs far better than many traditional artificial feature extraction methods with the help of standalone filter learning and multiscale local feature combination. Such structure cascaded by both linear layers with convolution filters and non-linear layers in binarization process shows better adaptability in different databases. With the help of parallel computing, training time is much shorter than PCANet and also more fixed compared to convolutional neural network. Experiment in LFW and FERET shows that such a data oriented structure shows good performance both on stability and accuracy in various environments.</p>

  
  <div class="row">
    <div class="col-sm-1"></div>
    <div class="col-sm-10">
      <div class="row">
        <div class="col-xs-12 col-sm-3 pub-row-heading">Type</div>
        <div class="col-xs-12 col-sm-9">
          
          <a href="/publication/#6">
            Book chapter
          </a>
          
        </div>
      </div>
    </div>
    <div class="col-sm-1"></div>
  </div>
  <div class="visible-xs space-below"></div>
  

  <div class="row">
    <div class="col-sm-1"></div>
    <div class="col-sm-10">
      <div class="row">
        <div class="col-xs-12 col-sm-3 pub-row-heading">Publication</div>
        <div class="col-xs-12 col-sm-9">In Chinese Conference on Biometric Recognition <em>(CCBR)</em>, Springer.</div>
      </div>
    </div>
    <div class="col-sm-1"></div>
  </div>
  <div class="visible-xs space-below"></div>

  <div class="row">
    <div class="col-sm-1"></div>
    <div class="col-sm-10">
      <div class="row">
        <div class="col-xs-12 col-sm-3 pub-row-heading">Date</div>
        <div class="col-xs-12 col-sm-9" itemprop="datePublished">
          October, 2015
        </div>
      </div>
    </div>
    <div class="col-sm-1"></div>
  </div>
  <div class="visible-xs space-below"></div>

  <div class="row" style="padding-top: 10px">
    <div class="col-sm-1"></div>
    <div class="col-sm-10">
      <div class="row">
        <div class="col-xs-12 col-sm-3 pub-row-heading" style="line-height:34px;">Links</div>
        <div class="col-xs-12 col-sm-9">

          




<a class="btn btn-primary btn-outline" href="https://www.researchgate.net/publication/291692599_Face_Recognition_Using_Local_PCA_Filters">
  PDF
</a>




<a class="btn btn-primary btn-outline" href="https://github.com/wangyida/PCANet">
  Code
</a>


<a class="btn btn-primary btn-outline" href="http://vis-www.cs.umass.edu/lfw/">
  Dataset
</a>


<a class="btn btn-primary btn-outline" href="https://wangyida.github.io/project/deep-learning/">
  Project
</a>




        </div>
      </div>
    </div>
    <div class="col-sm-1"></div>
  </div>
  <div class="visible-xs space-below"></div>

  <div class="space-below"></div>

  <div class="article-style">

<p><img src="/img/StandAloneNet.svg" alt="StandAloneNet" />
<img src="/img/filterFFT.svg" alt="filterFFT" /></p>

<h2 id="method">Method</h2>

<h3 id="filter-learning">Filter Learning</h3>

<h4 id="the-1st-stage-training">the 1st Stage Training</h4>

<p>Like the 1st stage training in PCANet, given $\textit{N}$ training samples $ \textit{I}_{i=1}^{\textit{N}} $ with the same size of $ \textit{m} \times \textit{n} $. The patch size doesn&rsquo;t change in a certain cascading queue, so multiscale filter banks is trained separately.</p>

<p>Overlapping patches in a particular size of images are collected for training a filter bank using SVD(Singular Value Decomposition). Patches are combined of adjacent pixels. As for the pixels on the edge of a image, we use zero padding to make it still useful. Patch mean is subtracted from each patch before SVD. Then the whole resource for filter training is represented as $\textit{X} = [ \bar{X}_1,\bar{X}_2,&hellip;,\bar{X}_N ] \in R^{k_1k_2*Nmn}$ where the image size of all $\textit{N}$ samples is $m \times n$ and the patch size is $\textit{k}_1 \times \textit{k}_2$.
A single patch feature matrix $ \bar{X}<em>1 $ extracted from an image is formed by a set of vectors as $ [ \bar{x}</em>{i,1},\bar{x}<em>{i,2},&hellip;,\bar{x}</em>{i,mn} ] $ where $ \bar{x}_{i,j} $ denotes the $ \textit{j} $th vectorized patches in the $ \textit{i} $th image.</p>

<p>The meaning of PCA is projecting the original data to another orthogonal space which uses as less basis as possible maximizing the variance of data, so basis in such orthogonal space is selected follows constraint: $\max_{V\in R^{k_1k_2 \times S_1}} ||V^TX||<em>F^2$ while $V^TV = I</em>{S_1}$ it is solved by eigenvalue decomposition of $XX^T $, so the convolution kernel could be expressed as</p>

<p>$$ W<em>l^1 = mat</em>{k_1,k_2}(q_l(XX^T)) \in R^{k_1 \times k_2}, l = 1,2,&hellip;,S_1 $$</p>

<p>where $S<em>1$ means the number of the set of principle eigenvectors in the 1st layer, $mat</em>{k_1,k_2}(v)$ is a reshaping function aims to transform $v$ to the size of $k_1 \times k_2$ and function $q_l(XX^T)$ denotes the $l$th principal eigenvector of $XX^T$ or the $l$th left singular vector of $X$.</p>

<p>Such goal is equivalent to minimize the reconstruction error with a set of eigenvectors as shown below where $I_{S_1}$ is identity matrix with the size of $L_1 \times L_2 $:</p>

<p>$$
\min_{V\in R^{k_1k_2 \times S_1}}||\textit{X} - \textit{VV}^TX ||<em>F^2, s.t: V^TV = I</em>{S_1}
    $$</p>

<h4 id="concatenated-filter-learning">Concatenated Filter Learning</h4>

<p>We optimize the concatenated structure to extract efficient feature by taking full advantage of textures in images and rearranging them properly. For the aim of enriching discriminative features and exploiting benefits from the detachment of the back propagation process, we train the cascaded layers only using the output of the particular convolution kernel. Feature extraction is also formed as a tree-like structure. No input-output pairs uses the same filter banks between two layers. As shown in Figure 2, this feature extraction process is a &lsquo;tree&rsquo; like concatenated structure rather than a &lsquo;chain&rsquo; like one of traditional PCANet. The number of filters in higher stages will be no smaller than previous stage, number of filters will only keep as the same when the remaining dimension of SVD is fixed as always 1 except for the $1st$ stage.</p>

<p>Assuming that layer $t$ contains $S_t$ filter sets where each set contains $l_t$ filters which could be represented as $l<em>t = \prod\limits</em>{L=1}^{t}S_L/S<em>t$ and such tree-like concatenate structure has $l</em>{total} = \prod\limits_{L=1}^{n}S<em>L$ outputs for one sample in all where $n$ is the number of layers used. In such a feature enriched network, benefit comes with the cost for the increasing of convolution kernels, which is $F = \sum</em>{t = 1}^{n}S_tl_t$ in total; Filters in stage $t$ is trained separately one by one from a single group of outputs of previous layer where the $l $th filter output of the $(t-1)$th stage is $I_i^l = I_i * W_l^{t-1}$ while $ i = 1,2,&hellip;,N$. One set of filters in such standalone training process only uses reconstructed samples from one filter in previous stage as source data, so different filters in previous layer would produce distinguishing learning resource where $*$ denotes 2D convolution and $N$ is always equal to the number of input images due to the standalone training process. Overlapping patches are collected as the same manner as the 1st layer. Patch means are removed from each patch as $\bar{Y}<em>i = [\bar{y}</em>{i,l,1},\bar{y}<em>{i,l,2},&hellip;,\bar{y}</em>{i,l,mn}]$ where $\bar{y}_{i,l,j}$ is the $j$th mean-subtracted patch in $I_i^l$. A single filter bank is then obtained from eigenvalue decomposition of ${Y}^l = [\bar{Y}_1^l,\bar{Y}_2^l,&hellip;,\bar{Y}_N^l] \in R^{k_1k<em>2 \times Nmn}$. To make images in different layers having the same size, zeros padding is applied before 2D convolution. Filter is solved as: $W</em>{l<em>t}^l = mat</em>{k_1,k_2}(ql(YY^T))\in R^{k_1 \times k_2}$ while $ l_t=1,2,&hellip;,S_l$. As filters is learned standalone, which means that the training data in previous stage is much fewer than PCANet. This means that data would be much fewer the original one for a single branch of filter learning, so less time will be cost on convolution with filter of previous stage. With the help of parallel computing, separate branches of current stage will be computed at the same time. Much training time will be saved.
Feature extracted by multiscale filters is beneficial to recognition. Here we just choose continuous odd numbers for filter scales $k_1$ and $k_2$. Convolution kernels are squares matrix for most of our experiment which means that $k_1 = k_2$.</p>

<p>\begin{figure}
\centering
\includegraphics[height=3cm]{filterFFT}
\caption{Multi scale Filters(odd-numbered rows) learned in the $1st$ layer and modulus of their FFT represented by 10 based $log$ function(even-numbered rows).}
\end{figure}</p>

<h3 id="feature-coding">Feature Coding</h3>

<p>Number of output images in the last layer equals to the amount of convolution filters, we represent discriminant features by regrouping and combining sets of outputs. All pixels in output images are converted to binaries with unit step function $S(.)$ whose output is 1 for positive input and 0 otherwise. A single threshold makes it possible for convolution results combining with each other properly and forming a more robust feature. Decimal number representing a single pixel is formed by concatenated binaries in the same position which are converted from convolutional output corresponding to a particular convolution kernel in the penultimate layer. Such reconstructed integer-valued (in range of $[0,1,&hellip;,2^{S<em>n-1}]$) image could be expressed as $\mathscr{O}^l = \sum</em>{s = 1}^{S<em>n}2^{s-1}S(\mathscr{I}^l*W</em>{s}^{n})$ where $s$ is the id of sets, $\mathscr{I}^l$ and $\mathscr{O}^l$ are a pair of input and output image in the last layer corresponding to the $l$th filter in the penultimate layer.</p>

<p>Every output image for a single scale of filter bank are partitioned into $B$ blocks for precisely statistics in histogram for images in normal view. Block histograms each with the same length of $2^{S_n}$ in an image are concatenated in a vector afterwards. In the next step, all vectors deriving from the same input image at the beginning are concatenated together in the same sequence to form the feature $f$ based on the filter scale $K_i$ which are all set as odd numbers.</p>

<p>\begin{equation}
f_k = [[Hist(\mathscr{I}_1^1),&hellip;,Hist(\mathscr{I}_B^1)],&hellip;,[Hist(\mathscr{I}<em>1^{l</em>{n-1}}),&hellip;,Hist(\mathscr{I}<em>B^{l</em>{n-1}})]]
\end{equation}</p>

<p>All features extracted from filters in several proper scales are concatenated to represent the feature of a sample $\mathscr{F} = [f_{K<em>1},f</em>{K<em>2},&hellip;,f</em>{K<em>n}$.
Based on the fact that the likelihood of concatenated features equals to the form represented as cosine distance computed by normalized feature vectors: $\sum</em>{k=K_1}^{K_n}&lt;\textit{Norm}(f_k^i),\textit{Norm}(f<em>k^j)&gt;$ equals to $&lt;\mathscr{F}^i,\mathscr{F}^j&gt;$ where $&lt;,&gt;$ denotes the matrix inner product, $\mathscr{F} = [\textit{Norm}(f</em>{K<em>1}),\textit{Norm}(f</em>{K<em>2}),&hellip;,\textit{Norm}(f</em>{K_n})]$, we carried out our experiment on such manner instead of concatenating all discriminant sub-feature together for the sake of saving memory in some databases. Such process could also be carried out after feature projection using classifiers as a mean of similarity fusion.</p>
</div>

</div>

<div class="container">
  <nav>
  <ul class="pager">
    

    
    <li class="next"><a href="https://wangyida.github.io/publication/icip16_wang/">Self-restraint object recognition by model based CNN learning <span
      aria-hidden="true">&rarr;</span></a></li>
    
  </ul>
</nav>

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2016 Yida Wang &middot; 

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js" integrity="sha512-jGsMH83oKe9asCpkOVkBnUrDDTp8wl+adkB2D+//JtlxO4SrLoJdhbOysIFQJloQFD+C4Fl1rMsQZF76JjV0eQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js" integrity="sha512-iHzEu7GbSc705hE2skyH6/AlTpOfBmkx7nUqTLGzPYR+C1tRaItbRlJ7hT/D3YQ9SV0fqLKzp4XY9wKulTBGTw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TweenMax.min.js" integrity="sha512-Z5heTz36xTemt1TbtbfXtTq5lMfYnOkXM2/eWcTTiLU01+Sw4ku1i7vScDc8fWhrP2abz9GQzgKH5NGBLoYlAw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/plugins/ScrollToPlugin.min.js" integrity="sha512-CDeU7pRtkPX6XJtF/gcFWlEwyaX7mcAp5sO3VIu/ylsdR74wEw4wmBpD5yYTrmMAiAboi9thyBUr1vXRPA7t0Q==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

